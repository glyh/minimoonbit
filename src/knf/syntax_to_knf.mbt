// REF: 
// 1. https://esumii.github.io/min-caml/tutorial-mincaml-9.eng.htm
// 2. https://www.cs.tufts.edu/comp/150VM/modules/09Aknormalize.html

// NOTE: Precondition is that every types on the tree is normalized
pub fn to_knf_with_tenv(kenv : KnfEnv, s : S) -> (Knf, T) {
  let q = KnfHeadQ::new()
  match s {
    Unit => (Unit, Unit)
    // NOTE: output type should be the type on KNF representation 
    Bool(b) => (Int(if b { 1 } else { 0 }), Int)
    Int(i) => (Int(i), Int)
    Double(f) => (Double(f), Double)
    Var(id) => {
      let v_name = kenv.new_name(id)
      match kenv.find(v_name) {
        None => @util.die("Unbound variable \{id} in KNF")
        Some(ty) => (Var(v_name), ty)
      }
    }
    Tuple(tup) => {
      for ti in tup.iter() {
        let ki = to_knf_with_tenv(kenv, ti)
        q.push(kenv, ki)
      }
      (q.refold_knf(Tuple(q.all_names())), Tuple(q.all_types()))
    }
    Not(b) => {
      q.push(kenv, (Int(1), Int))
      let b = to_knf_with_tenv(kenv, b)
      q.push(kenv, b)
      (q.refold_knf(Sub(q.at(0), q.at(1))), Int)
    }
    Array(len, ele) => {
      let len = to_knf_with_tenv(kenv, len)
      q.push(kenv, len)
      let ele = to_knf_with_tenv(kenv, ele)
      q.push(kenv, ele)
      let external_name = match ele.1 {
        Int => "minimbt_create_array"
        Double => "minimbt_create_float_array"
        _ => "minimbt_create_ptr_array"
      }
      (
        q.refold_knf(ExternalFunctionApplication(external_name, q.all_names())),
        Array(ele.1),
      )
    }
    Neg(num, ~kind) => {
      let num = to_knf_with_tenv(kenv, num)
      q.push(kenv, num)
      match kind {
        Double => (q.refold_knf(FNeg(q.at(0))), Double)
        Int => (q.refold_knf(Neg(q.at(0))), Int)
        ty => @util.die("Got \{ty} for `neg` in KNF")
      }
    }
    App(f, args) => {
      // NOTE: Any types generated by `to_knf_with_tenv` can be directly matched on
      let f = to_knf_with_tenv(kenv, f)
      q.push(kenv, f)
      let args = args.map(fn { arg => to_knf_with_tenv(kenv, arg) })
      args.each(fn { arg => q.push(kenv, arg) })
      let ret_ty = match f.1 {
        Fun(_, ret) => ret
        f => @util.die("Got \{f} for `app` in KNF")
      }
      (
        q.refold_knf(Apply(q.at(0), q.all_names().iter().drop(1).collect())),
        ret_ty,
      )
    }
    Get(arr, idx) => {
      let arr = to_knf_with_tenv(kenv, arr)
      q.push(kenv, arr)
      let idx = to_knf_with_tenv(kenv, idx)
      q.push(kenv, idx)
      let ret_ty = match arr.1 {
        Array(t) => t
        arr => @util.die("got \{arr} for `get` in KNF")
      }
      (q.refold_knf(Get(q.at(0), q.at(1))), ret_ty)
    }
    If(_test, _then, _else) => {
      let _test = to_knf_with_tenv(kenv, _test)
      q.push(kenv, _test)
      q.push(kenv, (Int(1), Int))
      let _then = to_knf_with_tenv(kenv, _then)
      let _else = to_knf_with_tenv(kenv, _else)
      (q.refold_knf(IfEq(q.at(0), q.at(1), _then.0, _else.0)), _then.1)
    }
    Prim(lhs, rhs, op, ~kind) => {
      let lhs = to_knf_with_tenv(kenv, lhs)
      q.push(kenv, lhs)
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push(kenv, rhs)
      let init = match (op, kind) {
        (Add, Int) => Add(q.at(0), q.at(1))
        (Sub, Int) => Sub(q.at(0), q.at(1))
        (Mul, Int) => Mul(q.at(0), q.at(1))
        (Div, Int) => Div(q.at(0), q.at(1))
        (Add, Double) => FAdd(q.at(0), q.at(1))
        (Sub, Double) => FSub(q.at(0), q.at(1))
        (Mul, Double) => FMul(q.at(0), q.at(1))
        (Div, Double) => FDiv(q.at(0), q.at(1))
        (_, ty) => @util.die("got \{ty} for `prim` in KNF")
      }
      (q.refold_knf(init), kind)
    }
    Eq(lhs, rhs) => {
      let lhs = to_knf_with_tenv(kenv, lhs)
      q.push(kenv, lhs)
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push(kenv, rhs)
      let _then = to_knf_with_tenv(kenv, Int(1))
      let _else = to_knf_with_tenv(kenv, Int(0))
      (q.refold_knf(IfEq(q.at(0), q.at(1), _then.0, _else.0)), _then.1)
    }
    LE(lhs, rhs) => {
      let lhs = to_knf_with_tenv(kenv, lhs)
      q.push(kenv, lhs)
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push(kenv, rhs)
      let _then = to_knf_with_tenv(kenv, Int(1))
      let _else = to_knf_with_tenv(kenv, Int(0))
      (q.refold_knf(IfLe(q.at(0), q.at(1), _then.0, _else.0)), _then.1)
    }
    Let((id, ty), rhs, rest) => {
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push_named(kenv, rhs, id)
      let rest = to_knf_with_tenv(kenv.add(q.at(0), ty), rest)
      (q.refold_knf(rest.0), rest.1)
    }
    LetRec(f, rest) => {
      let f = FuncDef::from_syntax(kenv, f)
      q.push_fn(f)
      let rest = to_knf_with_tenv(kenv.add(f.name, f.ty), rest)
      (q.refold_knf(rest.0), rest.1)
    }
    LetTuple(tup, rhs, rest) => {
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push(kenv, rhs)
      let tup = tup.map(fn { (id, ty) => (kenv.new_name(id), ty) })
      let inner_env = tup.fold(init=kenv, fn(env, ti) { env.add(ti.0, ti.1) })
      let rest = to_knf_with_tenv(inner_env, rest)
      (q.refold_knf(LetTuple(tup, q.at(0), rest.0)), rest.1)
    }
    Put(lhs, rhs, rest) => {
      let lhs = to_knf_with_tenv(kenv, lhs)
      q.push(kenv, lhs)
      let rhs = to_knf_with_tenv(kenv, rhs)
      q.push(kenv, rhs)
      let rest = to_knf_with_tenv(kenv, rest)
      q.push(kenv, rest)
      (q.refold_knf(Put(q.at(0), q.at(1), q.at(2))), rest.1)
    }
  }
}

pub fn KnfEnv::to_knf(self : KnfEnv, s : S) -> Knf {
  to_knf_with_tenv(self, s).0
}
